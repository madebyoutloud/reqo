---
title: Retry Logic
description: Automatic request retries with configurable backoff strategies.
---

The library includes built-in retry logic to handle transient failures automatically. This is particularly useful for network errors, rate limiting, and temporary server issues.

## Enabling Retries

Enable retries at the client level or per-request:

```ts
import { createClient } from '@outloud/reqo'

// Enable with defaults
const client = createClient({
  retry: true
})

// Or per-request
const data = await reqo.$get('/users', {}, {
  retry: true
})
```

## Options

Customize retry behavior with detailed options:

::field-group
  ::field{name="limit" type="number"}
    Maximum number of retry attempts. Defaults to `2`.
    
    ```ts
    const client = createClient({
      retry: {
        limit: 3  // Retry up to 3 times
      }
    })
    ```
  ::

  ::field{name="methods" type="RequestMethod[]"}
    HTTP methods that can be retried. Defaults to `['GET', 'HEAD', 'OPTIONS']`.
    
    ```ts
    const client = createClient({
      retry: {
        methods: ['GET', 'HEAD', 'OPTIONS', 'PUT', 'DELETE']
      }
    })
    ```
  ::

  ::field{name="statusCodes" type="number[]"}
    HTTP status codes that trigger retries. Defaults to `[408, 429, 500, 502, 503, 504, 520, 521, 522, 523, 524, 525, 526, 530]`.
    
    ```ts
    const client = createClient({
      retry: {
        statusCodes: [408, 429, 500, 502, 503, 504]
      }
    })
    ```
  ::

  ::field{name="codes" type="string[]"}
    Error codes that trigger retries. Defaults to `['ECONNRESET', 'ETIMEDOUT', 'ENOTFOUND', 'ECONNREFUSED', 'UND_ERR_SOCKET']`
    
    ```ts
    const client = createClient({
      retry: {
        codes: ['ECONNRESET', 'ETIMEDOUT']
      }
    })
    ```
  ::

  ::field{name="delay" type="DelayFn"}
    Delay function that returns milliseconds to wait before retry. Default: Exponential backoff `0.1 * (2 ** (retryCount - 1)) * 1000`
    
    ```ts
    const client = createClient({
      retry: {
        delay: (retryCount, error) => {
          // Linear backoff: 1s, 2s, 3s
          return retryCount * 1000
        }
      }
    })
    ```
  ::

  ::field{name="validate" type="ValidateFn"}
    Custom validation function to determine if retry should occur.
    
    ```ts
    const client = createClient({
      retry: {
        validate: (retryCount, error, options) => {
          // Custom retry logic
          return retryCount <= options.limit && error.status >= 500
        }
      }
    })
    ```
  ::
::

## Default Behavior

By default, retries are configured for:

- **Methods**: GET, HEAD, OPTIONS (safe, idempotent methods)
- **Status Codes**: 408, 429, 500, 502, 503, 504, 520-526, 530
- **Network Errors**: ECONNRESET, ETIMEDOUT, ENOTFOUND, ECONNREFUSED
- **Limit**: 2 retries
- **Delay**: Exponential backoff (100ms, 200ms, 400ms, ...)

```ts
// Default configuration
const defaultRetry = {
  limit: 2,
  methods: ['GET', 'HEAD', 'OPTIONS'],
  statusCodes: [408, 429, 500, 502, 503, 504, 520, 521, 522, 523, 524, 525, 526, 530],
  codes: ['ECONNRESET', 'ETIMEDOUT', 'ENOTFOUND', 'ECONNREFUSED', 'UND_ERR_SOCKET'],
  delay: (retryCount) => 0.1 * (2 ** (retryCount - 1)) * 1000
}
```

## Backoff Strategies

### Exponential Backoff (Default)

Doubles the delay between each retry:

```ts
const client = createClient({
  retry: {
    limit: 4,
    delay: (retryCount) => {
      // 100ms, 200ms, 400ms, 800ms
      return 0.1 * (2 ** (retryCount - 1)) * 1000
    }
  }
})
```

### Linear Backoff

Increases delay by a constant amount:

```ts
const client = createClient({
  retry: {
    limit: 3,
    delay: (retryCount) => {
      // 1s, 2s, 3s
      return retryCount * 1000
    }
  }
})
```

### Fixed Delay

Same delay between all retries:

```ts
const client = createClient({
  retry: {
    limit: 3,
    delay: () => 2000  // Always 2 seconds
  }
})
```

### Jittered Backoff

Add randomness to prevent thundering herd:

```ts
const client = createClient({
  retry: {
    limit: 3,
    delay: (retryCount) => {
      const baseDelay = 0.1 * (2 ** (retryCount - 1)) * 1000
      const jitter = Math.random() * 1000
      return baseDelay + jitter
    }
  }
})
```

### Custom Based on Error

Adjust delay based on the error:

```ts
const client = createClient({
  retry: {
    delay: (retryCount, error) => {
      // Longer delay for rate limiting
      if (error.status === 429) {
        const retryAfter = error.response?.headers.get('Retry-After')
        if (retryAfter) {
          return parseInt(retryAfter) * 1000
        }
        return 60000  // 1 minute
      }
      
      // Standard exponential backoff
      return 0.1 * (2 ** (retryCount - 1)) * 1000
    }
  }
})
```

## Retry-After Header

Handle the Retry-After response header:

```ts
const client = createClient({
  retry: {
    limit: 3,
    delay: (retryCount, error) => {
      // Check for Retry-After header
      const retryAfter = error.response?.headers.get('Retry-After')
      
      if (retryAfter) {
        // Retry-After can be seconds or HTTP date
        const delay = parseInt(retryAfter)
        if (!isNaN(delay)) {
          return delay * 1000
        }
        
        // Parse as date
        const date = new Date(retryAfter)
        return date.getTime() - Date.now()
      }
      
      // Default backoff
      return retryCount * 1000
    }
  }
})
```

## Retrying Non-Idempotent Methods

By default, only safe methods (GET, HEAD, OPTIONS) are retried. To retry POST, PUT, PATCH, DELETE:

```ts
const client = createClient({
  retry: {
    limit: 2,
    methods: ['GET', 'HEAD', 'OPTIONS', 'POST', 'PUT', 'PATCH', 'DELETE']
  }
})

// Or per-request
await reqo.$post('/users', userData, {
  retry: {
    limit: 2,
    methods: ['POST']
  }
})
```

::warning
Be careful when retrying non-idempotent methods (POST, PATCH) as they may cause duplicate operations.
::

## Status Code Filtering

Retry only specific status codes:

```ts
const client = createClient({
  retry: {
    // Only retry server errors
    statusCodes: [500, 502, 503, 504]
  }
})

// Only retry rate limiting
const rateLimitClient = createClient({
  retry: {
    statusCodes: [429],
    delay: (retryCount, error) => {
      const retryAfter = error.response?.headers.get('Retry-After')
      return retryAfter ? parseInt(retryAfter) * 1000 : 60000
    }
  }
})
```

## Network Error Handling

Retry on specific network errors:

```ts
const client = createClient({
  retry: {
    codes: [
      'ECONNRESET',      // Connection reset
      'ETIMEDOUT',       // Timeout
      'ENOTFOUND',       // DNS lookup failed
      'ECONNREFUSED',    // Connection refused
      'UND_ERR_SOCKET'   // Undici socket error
    ]
  }
})
```

## Custom Validation

Implement complex retry logic with validation function:

```ts
const client = createClient({
  retry: {
    validate: (retryCount, error, options) => {
      // Don't retry after limit
      if (retryCount > options.limit) {
        return false
      }
      
      // Don't retry client errors (4xx except 429)
      if (error.status >= 400 && error.status < 500 && error.status !== 429) {
        return false
      }
      
      // Don't retry on specific error messages
      if (error.message.includes('Invalid token')) {
        return false
      }
      
      // Retry server errors and network issues
      return error.status >= 500 || error.code !== ''
    }
  }
})
```

## Per-Request Retry

Override client retry settings for specific requests:

```ts
const client = createClient({
  retry: {
    limit: 2,
    methods: ['GET']
  }
})

// This request has different retry config
const data = await client.$post('/users', userData, {
  retry: {
    limit: 5,
    methods: ['POST'],
    delay: (count) => count * 2000
  }
})

// This request has no retry
const noRetry = await client.$get('/users', {}, {
  retry: false
})
```

## Timeouts and Retries

When using both timeouts and retries, the total time includes all retry attempts:

```ts
const client = createClient({
  timeout: 10000,  // 10 second total timeout
  retry: {
    limit: 3,
    delay: (count) => count * 1000  // 1s, 2s, 3s
  }
})

// If the first attempt takes 8s and fails, the retry will be
// canceled after 2s to respect the 10s total timeout
```

## Practical Examples

### API with Rate Limiting

```ts
const api = createClient({
  url: 'https://api.example.com',
  retry: {
    limit: 5,
    statusCodes: [429, 503],
    delay: (retryCount, error) => {
      if (error.status === 429) {
        const retryAfter = error.response?.headers.get('Retry-After')
        return retryAfter ? parseInt(retryAfter) * 1000 : 60000
      }
      return retryCount * 1000
    }
  }
})
```

### Unreliable Network

```ts
const unreliableApi = createClient({
  url: 'https://unreliable-service.com',
  retry: {
    limit: 5,
    methods: ['GET', 'POST', 'PUT', 'DELETE'],
    codes: ['ECONNRESET', 'ETIMEDOUT', 'ENOTFOUND'],
    delay: (count) => {
      // Aggressive exponential backoff with jitter
      const base = 0.5 * (2 ** (count - 1)) * 1000
      const jitter = Math.random() * 500
      return base + jitter
    }
  }
})
```
