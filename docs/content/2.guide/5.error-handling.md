---
title: Error Handling
description: Comprehensive error handling and custom error types.
---

The library provides rich error types with detailed context about failed requests, making debugging and error handling straightforward.

## Error Types

All HTTP errors extend from `RequestError`:

```ts
import { errors } from '@outloud/reqo'

// Base error class
errors.RequestError

// Specific error types
errors.TimeoutError   // Request timed out
errors.CanceledError  // Request was canceled
```

## Checking Errors

### Using isError Method

The recommended way to check for HTTP errors:

```ts
import { reqo } from '@outloud/reqo'

try {
  const data = await reqo.$get('/users/999')
} catch (error) {
  if (reqo.isError(error)) {
    // error is typed as RequestError
    console.log('Status:', error.status)
    console.log('Message:', error.message)
    console.log('URL:', error.url)
  }
}
```

### Using instanceof

Check for specific error types:

```ts
import { errors } from '@outloud/reqo'

try {
  const data = await reqo.$get('/users', {}, { timeout: 1000 })
} catch (error) {
  if (error instanceof errors.TimeoutError) {
    console.log('Request timed out')
  } else if (error instanceof errors.CanceledError) {
    console.log('Request was canceled')
  } else if (error instanceof errors.RequestError) {
    console.log('Other request error:', error.status)
  }
}
```

## Error Properties

::field-group
  ::field{name="message" type="string"}
    Error message describing what went wrong.
    
    ```ts
    error.message  // 'Request failed with status code 404.'
    ```
  ::

  ::field{name="status" type="number"}
    HTTP status code of the response. Defaults to `-1` if no response was received.
    
    ```ts
    error.status  // 404, 500, -1, etc.
    ```
  ::

  ::field{name="code" type="string"}
    Error code. Empty string for HTTP errors, or network error codes like 'ETIMEDOUT', 'ECONNREFUSED'.
    
    ```ts
    error.code  // '', 'E_TIMEOUT', 'E_CANCELED', 'ECONNRESET'
    ```
  ::

  ::field{name="url" type="string"}
    The request URL that failed.
    
    ```ts
    error.url  // 'https://api.example.com/users/999'
    ```
  ::

  ::field{name="method" type="string"}
    HTTP method used for the request.
    
    ```ts
    error.method  // 'GET', 'POST', etc.
    ```
  ::

  ::field{name="params" type="Params | undefined"}
    Query parameters sent with the request.
    
    ```ts
    error.params  // { id: 123, status: 'active' }
    ```
  ::

  ::field{name="data" type="any"}
    Response body data if available.
    
    ```ts
    error.data  // { error: { message: 'Not found' } }
    ```
  ::

  ::field{name="client" type="string | undefined"}
    Client ID if one was set.
    
    ```ts
    error.client  // 'github-api'
    ```
  ::

  ::field{name="config" type="RequestConfig"}
    Full request configuration (hidden from enumeration but accessible).
    
    ```ts
    error.config.headers
    error.config.timeout
    ```
  ::

  ::field{name="request" type="Request"}
    The Request object passed to fetch (hidden from enumeration).
    
    ```ts
    error.request.headers
    ```
  ::

  ::field{name="response" type="Response | undefined"}
    The Response object if one was received (hidden from enumeration).
    
    ```ts
    error.response?.headers
    error.response?.status
    ```
  ::

  ::field{name="cause" type="Error | undefined"}
    Original error that caused this error.
    
    ```ts
    error.cause  // Original network error
    ```
  ::
::

## Error Serialization

Errors can be serialized to JSON:

```ts
try {
  await reqo.$get('/users/999', { search: 'test' })
} catch (error) {
  if (reqo.isError(error)) {
    const json = error.toJSON()
    console.log(json)
    /*
    {
      client: 'api-client',
      url: 'https://api.example.com/users/999',
      params: { search: 'test' },
      method: 'GET',
      message: 'Request failed with status code 404.',
      code: '',
      status: 404,
      data: { error: { message: 'User not found' } }
    }
    */
  }
}
```

## Status Code Handling

Handle different HTTP status codes:

```ts
try {
  const user = await reqo.$get('/users/123')
} catch (error) {
  if (!reqo.isError(error)) throw error
  
  switch (error.status) {
    case 400:
      console.error('Bad request:', error.data)
      break
    case 401:
      console.error('Unauthorized - please login')
      // Redirect to login
      break
    case 403:
      console.error('Forbidden - insufficient permissions')
      break
    case 404:
      console.error('User not found')
      break
    case 429:
      console.error('Rate limited - try again later')
      const retryAfter = error.response?.headers.get('Retry-After')
      console.log(`Retry after ${retryAfter} seconds`)
      break
    case 500:
    case 502:
    case 503:
      console.error('Server error - try again')
      break
    default:
      console.error('Unexpected error:', error.status)
  }
}
```

## Network Error Handling

Handle network-level errors:

```ts
try {
  const data = await reqo.$get('https://api.example.com/data')
} catch (error) {
  if (!reqo.isError(error)) throw error
  
  switch (error.code) {
    case 'ECONNREFUSED':
      console.error('Connection refused - server may be down')
      break
    case 'ETIMEDOUT':
      console.error('Connection timed out')
      break
    case 'ENOTFOUND':
      console.error('DNS lookup failed - check the URL')
      break
    case 'ECONNRESET':
      console.error('Connection reset by server')
      break
    case 'E_TIMEOUT':
      console.error('Request timeout exceeded')
      break
    case 'E_CANCELED':
      console.error('Request was canceled')
      break
    default:
      if (error.status === -1) {
        console.error('Network error:', error.message)
      }
  }
}
```

## Response Data Access

Handle API validation errors:

```ts
interface ValidationError {
  field: string
  message: string
}

interface ApiError {
  message: string
  errors?: ValidationError[]
}

try {
  await reqo.$post<User, CreateUserDto>('/users', {
    name: '',
    email: 'invalid'
  })
} catch (error) {
  if (reqo.isError(error) && error.status === 422) {
    const apiError = error.data as ApiError
    
    apiError.errors?.forEach((err) => {
      console.error(`${err.field}: ${err.message}`)
    })
  }
}
```

## Global Error Handler

Set up a global error handler:

```ts
import { createClient } from '@outloud/reqo'

const client = createClient({
  url: 'https://api.example.com'
})

client.on('error', (error) => {
  // Log all errors
  console.error('API Error:', {
    url: error.url,
    method: error.method,
    status: error.status,
    message: error.message
  })
  
  // Send to error tracking service
  if (error.status >= 500) {
    errorTracker.captureException(error)
  }
  
  // Show user-friendly messages
  if (error.status === 401) {
    toast.error('Please log in to continue')
  } else if (error.status >= 500) {
    toast.error('Server error. Please try again later.')
  }
})
```

## Best Practices

1. **Always check error types**: Use `reqo.isError()` or `instanceof` to type-check errors
2. **Handle specific status codes**: Provide user-friendly messages for common errors
3. **Log errors**: Send error details to monitoring services
4. **Serialize carefully**: Use `error.toJSON()` for logging, but be aware it may contain sensitive data
5. **Don't swallow errors**: Re-throw unexpected errors
6. **Provide fallbacks**: Return cached data or defaults when appropriate
7. **User-friendly messages**: Transform technical errors into actionable messages
